<!DOCTYPE html>
<html><head><meta charset="UTF-8"><link href="css/default.css" rel="stylesheet" type="text/css"><script src="js/jquery.min.js" type="text/javascript"></script><script src="js/page_effects.js" type="text/javascript"></script><title>ednsl documentation</title></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a></h2><h1><a href="index.html">Ednsl 0.2.1 API documentation</a></h1></div><div class="sidebar" id="namespaces"><h3><a href="index.html"><span class="inner">Namespaces</span></a></h3><ul><li class="depth-1 current"><a href="ednsl.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>ednsl</span></div></a></li><li class="depth-2"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>util</span></div></div></li><li class="depth-3"><a href="ednsl.util.either.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>either</span></div></a></li></ul></div><div class="sidebar" id="vars"><h3><a href="#top"><span class="inner">Public Vars</span></a></h3><ul><li class="depth-1"><a href="ednsl.html#var--.3ECtxForm"><div class="inner"><span>-&gt;CtxForm</span></div></a></li><li class="depth-1"><a href="ednsl.html#var-.3E.3E-"><div class="inner"><span>&gt;&gt;-</span></div></a></li><li class="depth-1"><a href="ednsl.html#var-.3E.3E.3D"><div class="inner"><span>&gt;&gt;=</span></div></a></li><li class="depth-1"><a href="ednsl.html#var-add-context"><div class="inner"><span>add-context</span></div></a></li><li class="depth-1"><a href="ednsl.html#var-branch"><div class="inner"><span>branch</span></div></a></li><li class="depth-1"><a href="ednsl.html#var-cf-form"><div class="inner"><span>cf-form</span></div></a></li><li class="depth-1"><a href="ednsl.html#var-collect"><div class="inner"><span>collect</span></div></a></li><li class="depth-1"><a href="ednsl.html#var-ctx-form"><div class="inner"><span>ctx-form</span></div></a></li><li class="depth-1"><a href="ednsl.html#var-ctx-pred"><div class="inner"><span>ctx-pred</span></div></a></li><li class="depth-1"><a href="ednsl.html#var-eany"><div class="inner"><span>eany</span></div></a></li><li class="depth-1"><a href="ednsl.html#var-ebool"><div class="inner"><span>ebool</span></div></a></li><li class="depth-1"><a href="ednsl.html#var-ecount"><div class="inner"><span>ecount</span></div></a></li><li class="depth-1"><a href="ednsl.html#var-efalse"><div class="inner"><span>efalse</span></div></a></li><li class="depth-1"><a href="ednsl.html#var-efn"><div class="inner"><span>efn</span></div></a></li><li class="depth-1"><a href="ednsl.html#var-eint"><div class="inner"><span>eint</span></div></a></li><li class="depth-1"><a href="ednsl.html#var-eithery"><div class="inner"><span>eithery</span></div></a></li><li class="depth-1"><a href="ednsl.html#var-eithery*"><div class="inner"><span>eithery*</span></div></a></li><li class="depth-1"><a href="ednsl.html#var-ekey"><div class="inner"><span>ekey</span></div></a></li><li class="depth-1"><a href="ednsl.html#var-ekeys"><div class="inner"><span>ekeys</span></div></a></li><li class="depth-1"><a href="ednsl.html#var-elist"><div class="inner"><span>elist</span></div></a></li><li class="depth-1"><a href="ednsl.html#var-eload-sym"><div class="inner"><span>eload-sym</span></div></a></li><li class="depth-1"><a href="ednsl.html#var-emap"><div class="inner"><span>emap</span></div></a></li><li class="depth-1"><a href="ednsl.html#var-enil"><div class="inner"><span>enil</span></div></a></li><li class="depth-1"><a href="ednsl.html#var-eor"><div class="inner"><span>eor</span></div></a></li><li class="depth-1"><a href="ednsl.html#var-epred"><div class="inner"><span>epred</span></div></a></li><li class="depth-1"><a href="ednsl.html#var-estr"><div class="inner"><span>estr</span></div></a></li><li class="depth-1"><a href="ednsl.html#var-esym"><div class="inner"><span>esym</span></div></a></li><li class="depth-1"><a href="ednsl.html#var-etrue"><div class="inner"><span>etrue</span></div></a></li><li class="depth-1"><a href="ednsl.html#var-etuple"><div class="inner"><span>etuple</span></div></a></li><li class="depth-1"><a href="ednsl.html#var-etuple-chain"><div class="inner"><span>etuple-chain</span></div></a></li><li class="depth-1"><a href="ednsl.html#var-evals"><div class="inner"><span>evals</span></div></a></li><li class="depth-1"><a href="ednsl.html#var-evec"><div class="inner"><span>evec</span></div></a></li><li class="depth-1"><a href="ednsl.html#var-fail"><div class="inner"><span>fail</span></div></a></li><li class="depth-1"><a href="ednsl.html#var-invert"><div class="inner"><span>invert</span></div></a></li><li class="depth-1"><a href="ednsl.html#var-left"><div class="inner"><span>left</span></div></a></li><li class="depth-1"><a href="ednsl.html#var-left.3F"><div class="inner"><span>left?</span></div></a></li><li class="depth-1"><a href="ednsl.html#var-map-.3ECtxForm"><div class="inner"><span>map-&gt;CtxForm</span></div></a></li><li class="depth-1"><a href="ednsl.html#var-read-file"><div class="inner"><span>read-file</span></div></a></li><li class="depth-1"><a href="ednsl.html#var-read-str"><div class="inner"><span>read-str</span></div></a></li><li class="depth-1"><a href="ednsl.html#var-replace-form*"><div class="inner"><span>replace-form*</span></div></a></li><li class="depth-1"><a href="ednsl.html#var-right"><div class="inner"><span>right</span></div></a></li><li class="depth-1"><a href="ednsl.html#var-right.3F"><div class="inner"><span>right?</span></div></a></li><li class="depth-1"><a href="ednsl.html#var-update-form*"><div class="inner"><span>update-form*</span></div></a></li><li class="depth-1"><a href="ednsl.html#var-when-left"><div class="inner"><span>when-left</span></div></a></li><li class="depth-1"><a href="ednsl.html#var-when-left*"><div class="inner"><span>when-left*</span></div></a></li><li class="depth-1"><a href="ednsl.html#var-when-not-left*"><div class="inner"><span>when-not-left*</span></div></a></li><li class="depth-1"><a href="ednsl.html#var-when-not-right*"><div class="inner"><span>when-not-right*</span></div></a></li><li class="depth-1"><a href="ednsl.html#var-when-right"><div class="inner"><span>when-right</span></div></a></li><li class="depth-1"><a href="ednsl.html#var-when-right*"><div class="inner"><span>when-right*</span></div></a></li></ul></div><div class="namespace-docs" id="content"><h2 class="anchor" id="top">ednsl</h2><div class="doc"><pre class="plaintext"></pre></div><div class="public anchor" id="var--.3ECtxForm"><h3>-&gt;CtxForm</h3><div class="usage"><code>(-&gt;CtxForm form)</code></div><div class="doc"><pre class="plaintext">Positional factory function for class ednsl.CtxForm.
</pre></div></div><div class="public anchor" id="var-.3E.3E-"><h3>&gt;&gt;-</h3><div class="usage"></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-.3E.3E.3D"><h3>&gt;&gt;=</h3><div class="usage"></div><div class="doc"><pre class="plaintext">Pronounced &apos;bind&apos;. If the provided either is a Right, apply the given check
and recur along the rest of the chain, substituting the result of that check
for the original Either
Args: [either check &amp; [checks]]
Returns: either</pre></div></div><div class="public anchor" id="var-add-context"><h3>add-context</h3><div class="usage"><code>(add-context k v)</code></div><div class="doc"><pre class="plaintext">Given a key and a value, returns a function which adds the context to the
context form it is given and wraps it in a Right.
Args: [k v]
Returns: Function:
    Args: [ctx-form]
    Returns: right[ctx-form]</pre></div></div><div class="public anchor" id="var-branch"><h3>branch</h3><div class="usage"><code>(branch l-f r-f)</code></div><div class="doc"><pre class="plaintext">Given two functions, returns a function which executes one depending on
whether the value passed to it is a Left or a Right and returns the result
Provided functions are expected to take the value in the monad and are
easily chained by returning an Either
Args: [l-f r-f]
Returns: Function:
    Args: [Either]
    Returns: Any</pre></div></div><div class="public anchor" id="var-cf-form"><h3>cf-form</h3><div class="usage"></div><div class="doc"><pre class="plaintext">Returns the form from a given context form or else a default (default: nil)
Args: [ctx-form default?]
Returns: </pre></div></div><div class="public anchor" id="var-collect"><h3>collect</h3><div class="usage"><code>(collect coll)</code></div><div class="doc"><pre class="plaintext">Given a collection, returns a function which takes a collection of Eithers in a
ctx-form and casts it to the type of the original collection, folding the Eithers
in the collection into a single Either wrapping the cast collection
Args: [coll]
Returns: Function:
    Args: [cf]
    Returns: Either[ctx-form[typeof(coll)]]</pre></div></div><div class="public anchor" id="var-ctx-form"><h3>ctx-form</h3><div class="usage"><code>(ctx-form arg)</code></div><div class="doc"><pre class="plaintext">Constructs a context form. If arg is a map, expect a :form argument
else assume it is a form. Be careful with map data.
Args: [Any]
Returns: ctx-form</pre></div></div><div class="public anchor" id="var-ctx-pred"><h3>ctx-pred</h3><div class="usage"><code>(ctx-pred p exp-desc cf)</code></div><div class="doc"><pre class="plaintext">Returns a function which applies the predicate to the incoming data and
if truthy, returns the data, else fails with exp-desc
Args: [p exp-desc ctx-form]
Returns: Either[ctx-form]</pre></div></div><div class="public anchor" id="var-eany"><h3>eany</h3><div class="usage"></div><div class="doc"><pre class="plaintext">Matches anything.
Args: [ctx-form]
Returns: Right[ctx-form]</pre></div></div><div class="public anchor" id="var-ebool"><h3>ebool</h3><div class="usage"></div><div class="doc"><pre class="plaintext">Expects false
Args: [ctx-form]
Returns: Either[ctx-form]</pre></div></div><div class="public anchor" id="var-ecount"><h3>ecount</h3><div class="usage"><code>(ecount cnt)</code><code>(ecount low high)</code></div><div class="doc"><pre class="plaintext">Expects that the count of the form is either cnt or between low and high
Args: [cnt] [low high]
Returns: Either[ctx-form]</pre></div></div><div class="public anchor" id="var-efalse"><h3>efalse</h3><div class="usage"></div><div class="doc"><pre class="plaintext">Expects false
Args: [ctx-form]
Returns: Either[ctx-form]</pre></div></div><div class="public anchor" id="var-efn"><h3>efn</h3><div class="usage"></div><div class="doc"><pre class="plaintext">Expects a function. Useful for e.g. evaluating lists
Args: [ctx-form]
Returns: Either[ctx-form]</pre></div></div><div class="public anchor" id="var-eint"><h3>eint</h3><div class="usage"></div><div class="doc"><pre class="plaintext">Expects an integer
Args: [ctx-form]
Returns: Either[ctx-form]</pre></div></div><div class="public anchor" id="var-eithery"><h3>eithery</h3><div class="usage"><code>(eithery epred)</code></div><div class="doc"><pre class="plaintext">Returns a function that asserts that all the contents of the given form
in the ctx-form match a given epred (which implies the form is a coll)
That function returns a Right wrapping a ctx-form constructed by reusing
the context and replacing the form with a new form constructed by turning
the results into a new collection
We try to do the right thing, so play around in the repl 
The new ctx-form 
Args: [epred]
Returns: Function:
    Args: [ctx-form]
    Returns:Either[ctx-form]</pre></div></div><div class="public anchor" id="var-eithery*"><h3>eithery*</h3><div class="usage"><code>(eithery* f cf)</code></div><div class="doc"><pre class="plaintext">Takes a function and a collection and returns either the first Left result
of calling the f with an element of the collection or a new collection
made from the results in a Right. This means you can mutate in-transit.
Args: [f coll ctx-form]
Returns: Either[ctx-form]</pre></div></div><div class="public anchor" id="var-ekey"><h3>ekey</h3><div class="usage"></div><div class="doc"><pre class="plaintext">Expects a keyword
Args: [ctx-form]
Returns: Either[ctx-form]</pre></div></div><div class="public anchor" id="var-ekeys"><h3>ekeys</h3><div class="usage"><code>(ekeys epred)</code></div><div class="doc"><pre class="plaintext">Returns a function which expects a map where all keys match a given epred
Args: [epred]
Returns: Function:
    Args: [ctx-form]
    Returns: Either[ctx-form]</pre></div></div><div class="public anchor" id="var-elist"><h3>elist</h3><div class="usage"></div><div class="doc"><pre class="plaintext">Expects a list
Args: [ctx-form]
Returns: Either[ctx-form]</pre></div></div><div class="public anchor" id="var-eload-sym"><h3>eload-sym</h3><div class="usage"><code>(eload-sym {:keys [form], :as cf})</code></div><div class="doc"><pre class="plaintext">Takes a context form which is expected to be a fully qualified symbol.
Namespace will be required and the symbol will be resolved if it exists
On success, updates the ctx-form with the value of the symbol and wraps in
a Right, else returns a Left.
Args: [cf]
Returns: Either[ctx-form]</pre></div></div><div class="public anchor" id="var-emap"><h3>emap</h3><div class="usage"></div><div class="doc"><pre class="plaintext">Expects a map
Args: [ctx-form]
Returns: Either[ctx-form]</pre></div></div><div class="public anchor" id="var-enil"><h3>enil</h3><div class="usage"></div><div class="doc"><pre class="plaintext">Expects nil
Args: [ctx-form]
Returns: Either[ctx-form]</pre></div></div><div class="public anchor" id="var-eor"><h3>eor</h3><div class="usage"><code>(eor desc &amp; epreds)</code></div><div class="doc"><pre class="plaintext">Given some epreds, returns a function which returns the first Right
respon se or else a Left
Args: [&amp; epreds]
Returns: Function:
    Args: [ctx-form]
    Returns: Either[ctx-form]</pre></div></div><div class="public anchor" id="var-epred"><h3>epred</h3><div class="usage"><code>(epred p exp-desc)</code></div><div class="doc"><pre class="plaintext">Given a predicate function, Returns a function in the Either monad based
on whether the predicate returns a truthy value
Args: [p exp]
  p: predicate. Ordinary clojure function whose return should be boolish
  exp: generally a string, but anything descriptive (e.g. map), for ex-info
Returns: Function:
    Args: [ctx-form]
    Returns: Either[ctx-form]</pre></div></div><div class="public anchor" id="var-estr"><h3>estr</h3><div class="usage"></div><div class="doc"><pre class="plaintext">Expects a string
Args: [ctx-form]
Returns: Either[ctx-form]</pre></div></div><div class="public anchor" id="var-esym"><h3>esym</h3><div class="usage"></div><div class="doc"><pre class="plaintext">Expects a symbol
Args: [ctx-form]
Returns: Either[ctx-form]</pre></div></div><div class="public anchor" id="var-etrue"><h3>etrue</h3><div class="usage"></div><div class="doc"><pre class="plaintext">Expects true
Args: [ctx-form]
Returns: Either[ctx-form]</pre></div></div><div class="public anchor" id="var-etuple"><h3>etuple</h3><div class="usage"><code>(etuple &amp; epreds)</code></div><div class="doc"><pre class="plaintext">Given some preds, returns a function that expects a vector and zips the
epreds and the vector together returning either the first Left or else
a new right with a vector made up of the contents of the rights
Args: [&amp; preds]
Returns: Function:
    Args: [ctx-form]
    Returns: Either[ctx-form]</pre></div></div><div class="public anchor" id="var-etuple-chain"><h3>etuple-chain</h3><div class="usage"><code>(etuple-chain &amp; epreds)</code></div><div class="doc"><pre class="plaintext">Given some preds, returns a function that expects a vector and zips the
epreds and the vector together in a monadic chain (context propagates along
the chain so earlier functions can affect the context for later functions.
Returns either the first Left in the chain or a new right with a vector
made up of the contents of the rights
Args: [&amp; preds]
Returns: Function:
    Args: [ctx-form]
    Returns: Either</pre></div></div><div class="public anchor" id="var-evals"><h3>evals</h3><div class="usage"><code>(evals epred)</code></div><div class="doc"><pre class="plaintext">Returns a function which expects a map where all vals match a given epred
Args: [epred]
Returns: Function:
    Args: [ctx-form]
    Returns: Either[ctx-form]</pre></div></div><div class="public anchor" id="var-evec"><h3>evec</h3><div class="usage"></div><div class="doc"><pre class="plaintext">Expects a vector
Args: [ctx-form]
Returns: Either[ctx-form]</pre></div></div><div class="public anchor" id="var-fail"><h3>fail</h3><div class="usage"><code>(fail cf)</code><code>(fail extra cf)</code></div><div class="doc"><pre class="plaintext">Fails because some data was invalid. If extra-data-map is provided,
merges the maps together to provide failure info.
Args: [cf] [extra-data-map cf]
Returns: Right</pre></div></div><div class="public anchor" id="var-invert"><h3>invert</h3><div class="usage"><code>(invert f)</code></div><div class="doc"><pre class="plaintext">Wraps the provided function in a function which inverts the either result
provided, that is if it returns a left, return a right and vice versa.
Eg: `(&gt;&gt;= (invert #(left nil)) handle-error)`</pre></div></div><div class="public anchor" id="var-left"><h3>left</h3><div class="usage"></div><div class="doc"><pre class="plaintext">Creates a Left wrapping the provided value.
Args: [Any]
Returns: Left[Any]</pre></div></div><div class="public anchor" id="var-left.3F"><h3>left?</h3><div class="usage"></div><div class="doc"><pre class="plaintext">Is this a left? Any -&gt; Bool.
</pre></div></div><div class="public anchor" id="var-map-.3ECtxForm"><h3>map-&gt;CtxForm</h3><div class="usage"><code>(map-&gt;CtxForm m__5869__auto__)</code></div><div class="doc"><pre class="plaintext">Factory function for class ednsl.CtxForm, taking a map of keywords to field values.
</pre></div></div><div class="public anchor" id="var-read-file"><h3>read-file</h3><div class="usage"><code>(read-file path)</code></div><div class="doc"><pre class="plaintext">Reads file at path as edn
Args: [path]
Returns: clojure form</pre></div></div><div class="public anchor" id="var-read-str"><h3>read-str</h3><div class="usage"><code>(read-str str)</code></div><div class="doc"><pre class="plaintext">Reads the given string as edn
Args: [str]
Returns: clojure form</pre></div></div><div class="public anchor" id="var-replace-form*"><h3>replace-form*</h3><div class="usage"><code>(replace-form* new cf)</code></div><div class="doc"><pre class="plaintext">Given a new value and a ctx-form, replaces the form and returns a new ctx-form
Args: [new ctx-form]
Returns: ctx-form</pre></div></div><div class="public anchor" id="var-right"><h3>right</h3><div class="usage"></div><div class="doc"><pre class="plaintext">Creates a Right wrapping the provided value
Args: [Any]
Returns: Right[Any]</pre></div></div><div class="public anchor" id="var-right.3F"><h3>right?</h3><div class="usage"></div><div class="doc"><pre class="plaintext">Is this a right? Any -&gt; Bool.
</pre></div></div><div class="public anchor" id="var-update-form*"><h3>update-form*</h3><div class="usage"><code>(update-form* f cf)</code></div><div class="doc"><pre class="plaintext">Given a function f and a ctx-form cf, applies the form inside cf and returns
a new result with the form mutated to the return value of (f form) 
Args: [f ctx-form]
Returns: ctx-form</pre></div></div><div class="public anchor" id="var-when-left"><h3>when-left</h3><div class="usage"><code>(when-left f)</code></div><div class="doc"><pre class="plaintext">Given a function, returns a function which executes with the provided either
only when it is Left or else returns the value unchanged
NOTE: you cannot bind into this, because bind will never reach it
Correct example: `((when-left (&gt;&gt;- my monadic chain)) (left nil))
Args: [f]
Returns: Function:
   Args: [Any]
   Return: Right, or return-typeof(f)</pre></div></div><div class="public anchor" id="var-when-left*"><h3>when-left*</h3><h4 class="type">macro</h4><div class="usage"><code>(when-left* e &amp; exprs)</code></div><div class="doc"><pre class="plaintext">Given a value and a list of expressions, either runs the expressions if the
provided value is a Left or else returns the other value unmodified
Args: [e &amp; exprs]
Returns: result of exprs or value
Warning: Macro!</pre></div></div><div class="public anchor" id="var-when-not-left*"><h3>when-not-left*</h3><h4 class="type">macro</h4><div class="usage"><code>(when-not-left* e &amp; exprs)</code></div><div class="doc"><pre class="plaintext">Given an value and a list of expressions, either runs the expressions if the
provided value is not a Left or else return the Left unmodified
Args: [e &amp; exprs]
Returns: result of exprs or value
Warning: Macro!</pre></div></div><div class="public anchor" id="var-when-not-right*"><h3>when-not-right*</h3><h4 class="type">macro</h4><div class="usage"><code>(when-not-right* e &amp; exprs)</code></div><div class="doc"><pre class="plaintext">Given a value and a list of expressions, either runs the expressions if the
provided value is not a Right or else returns the other value unmodified
Args: [e &amp; exprs]
Returns: result of exprs or value
Warning: Macro!</pre></div></div><div class="public anchor" id="var-when-right"><h3>when-right</h3><div class="usage"><code>(when-right f)</code></div><div class="doc"><pre class="plaintext">Given a function, returns a function which executes with the provided value
only when it is Right or else returns the value unchanged
NOTE: you cannot bind into this, because bind will never reach it
Correct example: `((when-right (&gt;&gt;- my monadic chain)) (left nil))
Args: [f]
Returns: Function:
   Args: [Any]
   Return: Left, or return-typeof(f)</pre></div></div><div class="public anchor" id="var-when-right*"><h3>when-right*</h3><h4 class="type">macro</h4><div class="usage"><code>(when-right* e &amp; exprs)</code></div><div class="doc"><pre class="plaintext">Given a value and a list of expressions, either runs the expressions if the
provided value is a Right or else returns the other value unmodified
Args: [e &amp; exprs]
Returns: result of exprs or value
Warning: Macro!</pre></div></div></div></body></html>