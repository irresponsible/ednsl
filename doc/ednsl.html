<!DOCTYPE html>
<html><head><meta charset="UTF-8"><link href="css/default.css" rel="stylesheet" type="text/css"><script src="js/jquery.min.js" type="text/javascript"></script><script src="js/page_effects.js" type="text/javascript"></script><title>ednsl documentation</title></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a></h2><h1><a href="index.html">Ednsl 0.1.0-SNAPSHOT API documentation</a></h1></div><div class="sidebar" id="namespaces"><h3><a href="index.html"><span class="inner">Namespaces</span></a></h3><ul><li class="depth-1 current"><a href="ednsl.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>ednsl</span></div></a></li><li class="depth-2"><a href="ednsl.util.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>util</span></div></a></li><li class="depth-3"><a href="ednsl.util.either.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>either</span></div></a></li></ul></div><div class="sidebar" id="vars"><h3><a href="#top"><span class="inner">Public Vars</span></a></h3><ul><li class="depth-1"><a href="ednsl.html#var-add-context"><div class="inner"><span>add-context</span></div></a></li><li class="depth-1"><a href="ednsl.html#var-branch"><div class="inner"><span>branch</span></div></a></li><li class="depth-1"><a href="ednsl.html#var-ctx-form"><div class="inner"><span>ctx-form</span></div></a></li><li class="depth-1"><a href="ednsl.html#var-ecount"><div class="inner"><span>ecount</span></div></a></li><li class="depth-1"><a href="ednsl.html#var-eint"><div class="inner"><span>eint</span></div></a></li><li class="depth-1"><a href="ednsl.html#var-eithery"><div class="inner"><span>eithery</span></div></a></li><li class="depth-1"><a href="ednsl.html#var-ekey"><div class="inner"><span>ekey</span></div></a></li><li class="depth-1"><a href="ednsl.html#var-ekeys"><div class="inner"><span>ekeys</span></div></a></li><li class="depth-1"><a href="ednsl.html#var-elist"><div class="inner"><span>elist</span></div></a></li><li class="depth-1"><a href="ednsl.html#var-emap"><div class="inner"><span>emap</span></div></a></li><li class="depth-1"><a href="ednsl.html#var-eor"><div class="inner"><span>eor</span></div></a></li><li class="depth-1"><a href="ednsl.html#var-epred"><div class="inner"><span>epred</span></div></a></li><li class="depth-1"><a href="ednsl.html#var-estr"><div class="inner"><span>estr</span></div></a></li><li class="depth-1"><a href="ednsl.html#var-esym"><div class="inner"><span>esym</span></div></a></li><li class="depth-1"><a href="ednsl.html#var-etuple"><div class="inner"><span>etuple</span></div></a></li><li class="depth-1"><a href="ednsl.html#var-evals"><div class="inner"><span>evals</span></div></a></li><li class="depth-1"><a href="ednsl.html#var-evec"><div class="inner"><span>evec</span></div></a></li><li class="depth-1"><a href="ednsl.html#var-invert"><div class="inner"><span>invert</span></div></a></li><li class="depth-1"><a href="ednsl.html#var-left"><div class="inner"><span>left</span></div></a></li><li class="depth-1"><a href="ednsl.html#var-read-file"><div class="inner"><span>read-file</span></div></a></li><li class="depth-1"><a href="ednsl.html#var-read-str"><div class="inner"><span>read-str</span></div></a></li><li class="depth-1"><a href="ednsl.html#var-right"><div class="inner"><span>right</span></div></a></li><li class="depth-1"><a href="ednsl.html#var-when-left"><div class="inner"><span>when-left</span></div></a></li></ul></div><div class="namespace-docs" id="content"><h2 class="anchor" id="top">ednsl</h2><div class="doc"><pre class="plaintext"></pre></div><div class="public anchor" id="var-add-context"><h3>add-context</h3><div class="usage"><code>(add-context k v)</code></div><div class="doc"><pre class="plaintext">Given a key and a value, returns a function which adds the context to the
context form it is given.
Args: [k v]
Returns: Function:
    Args: [ctx-form]
    Returns: right[ctx-form]</pre></div></div><div class="public anchor" id="var-branch"><h3>branch</h3><div class="usage"><code>(branch l-f r-f)</code></div><div class="doc"><pre class="plaintext">Given two functions, returns a function which executes one depending on
whether the value passed to it is a left or a right and returns the result
Provided functions are expected to take the value in the monad and are
easily chained by returning an Either
Args: [l-f r-f]
Returns: Function:
    Args: [Either]
    Returns: Any</pre></div></div><div class="public anchor" id="var-ctx-form"><h3>ctx-form</h3><div class="usage"></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-ecount"><h3>ecount</h3><div class="usage"><code>(ecount cnt)</code><code>(ecount low high)</code></div><div class="doc"><pre class="plaintext">Expects that the count of the form is either cnt or between low and high
Args: [cnt] [low high]
Returns: Either[ctx-form]</pre></div></div><div class="public anchor" id="var-eint"><h3>eint</h3><div class="usage"></div><div class="doc"><pre class="plaintext">Expects an integer
Args: [ctx-form]
Returns: Either[ctx-form]</pre></div></div><div class="public anchor" id="var-eithery"><h3>eithery</h3><div class="usage"><code>(eithery epred)</code></div><div class="doc"><pre class="plaintext">Returns a function that asserts that all the contents of the given form
in the ctx-form match a given epred (which implies the form is a coll)
That function returns a Right wrapping a ctx-form constructed by reusing
the context and replacing the form with a new form constructed by turning
the results into a new collection
We try to do the right thing, so play around in the repl 
The new ctx-form 
Args: [epred]
Returns: Function:
    Args: [ctx-form]
    Returns:Either[ctx-form]</pre></div></div><div class="public anchor" id="var-ekey"><h3>ekey</h3><div class="usage"></div><div class="doc"><pre class="plaintext">Expects a keyword
Args: [ctx-form]
Returns: Either[ctx-form]</pre></div></div><div class="public anchor" id="var-ekeys"><h3>ekeys</h3><div class="usage"><code>(ekeys epred)</code></div><div class="doc"><pre class="plaintext">Returns a function which expects a map where all keys match a given epred
Args: [epred]
Returns: Function:
    Args: [ctx-form]
    Returns: Either[ctx-form]</pre></div></div><div class="public anchor" id="var-elist"><h3>elist</h3><div class="usage"></div><div class="doc"><pre class="plaintext">Expects a list
Args: [ctx-form]
Returns: Either[ctx-form]</pre></div></div><div class="public anchor" id="var-emap"><h3>emap</h3><div class="usage"></div><div class="doc"><pre class="plaintext">Expects a map
Args: [ctx-form]
Returns: Either[ctx-form]</pre></div></div><div class="public anchor" id="var-eor"><h3>eor</h3><div class="usage"><code>(eor desc &amp; epreds)</code></div><div class="doc"><pre class="plaintext">Given some epreds, returns a function which returns the first Right
respon se or else a Left
Args: [&amp; epreds]
Returns: Function:
    Args: [ctx-form]
    Returns: Either[ctx-form]</pre></div></div><div class="public anchor" id="var-epred"><h3>epred</h3><div class="usage"><code>(epred p exp-desc)</code></div><div class="doc"><pre class="plaintext">Given a predicate function, Returns a function in the Either monad based
on whether the predicate returns a truthy value
Args: [p exp]
  p: predicate. Ordinary clojure function whose return should be boolish
  exp: generally a string, but anything descriptive (e.g. map), for ex-info
Returns: Function:
    Args: [ctx-form]
    Returns: Either[ctx-form]</pre></div></div><div class="public anchor" id="var-estr"><h3>estr</h3><div class="usage"></div><div class="doc"><pre class="plaintext">Expects a string
Args: [ctx-form]
Returns: Either[ctx-form]</pre></div></div><div class="public anchor" id="var-esym"><h3>esym</h3><div class="usage"></div><div class="doc"><pre class="plaintext">Expects a symbol
Args: [ctx-form]
Returns: Either[ctx-form]</pre></div></div><div class="public anchor" id="var-etuple"><h3>etuple</h3><div class="usage"><code>(etuple &amp; epreds)</code></div><div class="doc"><pre class="plaintext">Given some preds, returns a function that expects a vector of that
many items, zips the epreds and the received vector and binds them
into a chain, returning either the first received Left or else a new
vector made up from the Rights, in a Right.
Args: [&amp; preds]
Returns: Function:
    Args: [ctx-form]
    Returns: Either</pre></div></div><div class="public anchor" id="var-evals"><h3>evals</h3><div class="usage"><code>(evals epred)</code></div><div class="doc"><pre class="plaintext">Returns a function which expects a map where all vals match a given epred
Args: [epred]
Returns: Function:
    Args: [ctx-form]
    Returns: Either[ctx-form]</pre></div></div><div class="public anchor" id="var-evec"><h3>evec</h3><div class="usage"></div><div class="doc"><pre class="plaintext">Expects a vector
Args: [ctx-form]
Returns: Either[ctx-form]</pre></div></div><div class="public anchor" id="var-invert"><h3>invert</h3><div class="usage"><code>(invert f)</code></div><div class="doc"><pre class="plaintext">Wraps the provided function in a function which inverts the either result
provided, that is if it returns a left, return a right and vice versa.
Eg: `(&gt;&gt;= (invert #(left nil)) handle-error)`</pre></div></div><div class="public anchor" id="var-left"><h3>left</h3><div class="usage"></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-read-file"><h3>read-file</h3><div class="usage"><code>(read-file path)</code></div><div class="doc"><pre class="plaintext">Reads file at path as edn
Args: [path]
Returns: clojure form</pre></div></div><div class="public anchor" id="var-read-str"><h3>read-str</h3><div class="usage"><code>(read-str str)</code></div><div class="doc"><pre class="plaintext">Reads the given string as edn
Args: [str]
Returns: clojure form</pre></div></div><div class="public anchor" id="var-right"><h3>right</h3><div class="usage"></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-when-left"><h3>when-left</h3><div class="usage"><code>(when-left f)</code></div><div class="doc"><pre class="plaintext">Given a function, returns a function which executes with the provided either
only when it is Left or else returns the right. when-right is spelled &apos;&gt;&gt;-&apos;
NOTE: you cannot bind into this, because bind will never reach it
Correct example: `(when-left (&gt;&gt;- my monadic chain) (left nil))
Args: [f]
Returns: Function:
   Args: [either]
   Return:</pre></div></div></div></body></html>